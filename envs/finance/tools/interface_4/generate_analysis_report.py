import json
from typing import Any, Dict, Optional, Tuple
import calendar
import re
from tau_bench.envs.tool import Tool


class GenerateAnalysisReport(Tool):

    @staticmethod
    def invoke(data: Dict[str, Any], report_type: str, period: str, 
               requester_role: str, analysis_fund_id: Optional[str] = None, 
               investor_id: Optional[str] = None) -> str:

        def _parse_period(period: str) -> Tuple[str, str]:
            """Parse reporting period into start_date and end_date (YYYY-MM-DD)."""
            period = str(period).strip().upper() # enforce the period to be a string and uppercase

            # Yearly: "2025"
            if re.fullmatch(r"\d{4}", period):
                year = int(period)
                return f"{year}-01-01", f"{year}-12-31"

            # Monthly: "2025-07"
            if re.fullmatch(r"\d{4}-\d{2}", period):
                year, month = map(int, period.split("-"))
                last_day = calendar.monthrange(year, month)[1]
                return f"{year}-{month:02d}-01", f"{year}-{month:02d}-{last_day}"

            # Snapshot: "2025-10-01"
            if re.fullmatch(r"\d{4}-\d{2}-\d{2}", period):
                return period, period

            # Quarterly: "Q1-2025"
            if re.fullmatch(r"Q[1-4]-\d{4}", period):
                q, year = period.split("-")
                year = int(year)
                q = int(q[1])
                month_start = (q - 1) * 3 + 1
                month_end = month_start + 2
                last_day = calendar.monthrange(year, month_end)[1]
                return f"{year}-{month_start:02d}-01", f"{year}-{month_end:02d}-{last_day}"

            # Half-year: "H1-2025" or "H2-2025"
            if re.fullmatch(r"H[12]-\d{4}", period):
                h, year = period.split("-")
                year = int(year)
                if h == "H1":
                    return f"{year}-01-01", f"{year}-06-30"
                else:
                    return f"{year}-07-01", f"{year}-12-31"

            raise ValueError(f"Unsupported period format: {period}")
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        reports = data.get("reports", {})
        funds = data.get("funds", {})
        investors = data.get("investors", {})
        users = data.get("users", {})
        
        # Validate report type
        valid_types = ["analysis_performance", "financial", "holding"]
        report_type = report_type.lower()
        if report_type not in valid_types:
            return json.dumps({"success": False, "message": f"Invalid report type. Must be one of {valid_types}"})
        
        # Map each report type to the allowed role
        role_permissions = {
            "analysis_performance": "fund_manager",
            "financial": "finance_officer",
            "holding": "finance_officer"
        }
        
        expected_role = role_permissions[report_type]
        if requester_role.lower() != expected_role:
            return json.dumps({
                "success": False,
                "message": f"{report_type.capitalize()} report can only be generated by a {expected_role}"
            })
        
        # If analysis_fund_id provided, validate it exists
        if analysis_fund_id and str(analysis_fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found"})
        
        # If investor_id provided, validate it exists
        if investor_id and str(investor_id) not in investors:
            return json.dumps({"success": False, "message": "Investor not found"})
        
        # Find a user with the appropriate role to be the generator
        generated_by = None
        for analysis_user_id, user in users.items():
            if user.get("role") == requester_role.lower():
                generated_by = analysis_user_id
                break
        
        if not generated_by:
            return json.dumps({"success": False, "message": "No authorized user found to generate report"})
        
        try:
            start_date, end_date = _parse_period(period)
        except ValueError as e:
            return json.dumps({"success": False, "message": str(e)})
        
        analysis_report_id = generate_id(reports)
        # timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S")
        timestamp = "2025-10-01T00:00:00"
        # Set analysis_fund_id to first available fund if not specified and needed
        if not analysis_fund_id and funds:
            analysis_fund_id = list(funds.keys())[0]
        
        new_report = {
            "analysis_report_id": analysis_report_id,
            "analysis_fund_id": analysis_fund_id,
            "investor_id": investor_id,
            "report_type": report_type,
            "report_start": start_date,
            "report_end": end_date,
            "generated_by": generated_by,
            "status": "completed",
            "created_at": timestamp
        }
        
        reports[str(analysis_report_id)] = new_report
        
        return json.dumps({"created_report": new_report})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "generate_report",
                "description": "Generate a report for funds or investors",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "report_type": {"type": "string", "description": "Type of report: analysis_performance, financial, holding"},
                        "analysis_fund_id": {"type": "string", "description": "ID of the fund 'optional'"},
                        "investor_id": {"type": "string", "description": "ID of the investor 'optional'"},
                        "period": {"type": "string", "description": "Reporting period (YYYY, YYYY-MM, YYYY-MM-DD, Qn-YYYY, Hn-YYYY)"},
                        "requester_role": {"type": "string", "description": "Role of the person requesting the report. The person can be fund_manager or a finance_officer"}
                    },
                    "required": ["report_type", "period", "requester_role"]
                }
            }
        }
